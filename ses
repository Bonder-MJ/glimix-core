from numpy.random import RandomState
from numpy import dot
from numpy import sqrt
from numpy_sugar.linalg import economic_qs
import logging

logging.basicConfig(level=logging.DEBUG)

import numpy as np

N = 500
random = RandomState(0)

X0 = random.randn(N, 5000)
K0 = X0.dot(X0.T)

QS0 = economic_qs(K0)

P = 499
K1 = QS0[0][0][:, :P].dot(np.diag(QS0[1][:P])).dot(QS0[0][0][:, :P].T)

from numpy import dot, sqrt, zeros

from numpy.random import RandomState

from numpy_sugar.linalg import economic_qs

from glimix_core.glmm import GLMM


ntrials = random.randint(1, 100, N)

z0 = dot(X0, random.randn(5000)) / sqrt(5000)
#z1 = dot(X1, random.randn(5)) / sqrt(5)

successes0 = zeros(len(ntrials), int)
#successes1 = zeros(len(ntrials), int)
for i in range(len(ntrials)):
    successes0[i] = sum(z0[i] + 0.2 * random.randn(ntrials[i]) > 0)
    
#for i in range(len(ntrials)):
#    successes1[i] = sum(z1[i] + 0.2 * random.randn(ntrials[i]) > 0)
    
y0 = (successes0, ntrials)
#y1 = (successes1, ntrials)
QS0 = economic_qs(K0)
QS1 = economic_qs(K1)
from numpy import ones

def func0():
    glmm0 = GLMM(y0, 'binomial', ones((N, 1)), QS0)
    glmm0.feed().maximize(progress=False)
    print(glmm0.value())

def func1():
    glmm1 = GLMM(y0, 'binomial', ones((N, 1)), QS1)
    glmm1.feed().maximize(progress=True)
    print(glmm1.value())

#func0()
func1()
#get_ipython().magic('timeit func0()')
#get_ipython().magic('timeit func1()')
